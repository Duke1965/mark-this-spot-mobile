# Project Overview
PINIT is a React Native mobile app for quick location marking: Users tap a circular button while driving to auto-drop pins based on speed/distance calculations, pulling Google Maps photos/details. An AI brain analyzes user patterns (e.g., pinned diners/shops, social shares) for personalized nearby recommendations on the ResultsScreen (star icon). Pins cluster with recommendation counts to avoid clutter. 98% complete—focus on fixes like map performance, offline pinning, AI suggestion speed. Prioritize non-coder-friendly UX, iOS/Android parity, secure Firebase sync.

# Tech Stack & Architecture
- Framework: React Native (Expo SDK ~50+), hooks-based, TypeScript for additions.
- Mapping: react-native-maps + expo-location; Google Maps API for place photos/queries (key in app.json).
- Backend: Firebase (Auth, Firestore for pins, Storage for photos). Config: /src/services/firebase.js.
- State: Redux Toolkit (/src/store) for pins/user; React Query for caching.
- Styling: NativeWind (e.g., "flex-1 p-4 bg-white rounded-lg"). Dark mode support.
- Navigation: @react-navigation (tabs/stack) for MapScreen, ResultsScreen, AuthScreen, PinDetailScreen.
- Key Dependencies: expo-location, react-native-maps, firebase, @reduxjs/toolkit, react-query, expo-image-picker.
- Folder Structure: [To be confirmed from repo: e.g., /src/screens (MapScreen.js), /src/components (PinMarker.js), /src/utils (locationUtils.js), /docs (CURSOR_HANDOVER.md, etc.)].
- Root Files: app.json (Expo config), package.json, README.md (if present).

# Coding Standards
- Naming: PascalCase components/files (e.g., PinDropButton.js), camelCase vars. Pin schema: id, lat, lng, title, description, category, photoUrl, recCount.
- Code: Hooks only; try-catch async (e.g., location calc, Google API fetches) with Expo toasts. JSDoc props. Memoize maps (useMemo).
- Style: Prettier + ESLint (`npm run lint`), 2-space indent. Accessibility: Labels for buttons/pins.
- Security: Firebase auth rules; validate inputs (PinForm.js). No exposed keys.
- Performance: Cluster pins (ClusterPin.js for counts); debounce button taps; offline Firestore caching.
- Testing: Jest for utils (e.g., speed calc in locationUtils.js); `npm test`.

# AI Behavior Guidelines (Cursor-Specific)
- Context: Use @filename (e.g., @ResultsScreen.js) or /ref. Start with "Per .cursorrules: [task]". Reference /docs for extras (e.g., DEPLOYMENT_GUIDE.md).
- Workflow: 
  - Bugs: Log issues (console.log for AI delays/map errors), run Expo sim, iterate fixes.
  - Features: Comment plan, add tests, implement, verify.
  - Pins/AI: Calc placement in locationUtils.js; fetch photos via googleMapsApi.js; track behavior in aiAnalytics.js.
- Output: ```diff changes + 2-sentence explain. Confirm commands (e.g., `expo install`). Loop reset: "Back to .cursorrules task."
- Avoid: Map render breaks, unrelated edits, online-only assumptions (test offline).
- Polish: Smooth clustering, fast recs, clear counts.

# Key Features & Patterns
- Pin Drop: Button triggers locationUtils.js (speed × time for retro-placement). Auto-fetch Google Maps data (photos, buildings).
- AI Recs: aiAnalytics.js monitors pins/shares; feeds ResultsScreen map (live location, clustered pins with counts on tap).
- Clustering: Group pins by proximity; show recCount badge (e.g., "7" for popular spots).
- Auth: Firebase (email/Google); useAuth hook guards routes.
- Offline: Queue pins/uploads; sync on reconnect.
- Deployment: Expo EAS per DEPLOYMENT_GUIDE.md; Firebase rules.

# Handover Integration
- CURSOR_HANDOVER.md: ChatGPT flows (e.g., simple UX for pin drops).
- PIN_MANAGEMENT_CONFIG.md: Categories (e.g., "diner", "shop") and sharing.
- DEPLOYMENT_GUIDE.md: Build/deploy steps.

Prompt: "Per .cursorrules: Optimize pin clustering on ResultsScreen.js." Update post-changes.
